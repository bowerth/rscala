> source("common.R",print.eval=TRUE)
# R version 3.4.0 (2017-04-21) # becker # FALSE # FALSE
> 
> 
> ####
> 
> 
> rng1 <- s %.~% "new scala.util.Random"
> rng1$nextDouble()
[1] 0.9141374
> 
> s$r1 <- rng1
> rng2 <- s$r1
> rng2$nextDouble()
[1] 0.07244385
> 
> rng3 <- s$.scala.util.Random$new()
> rng3$nextDouble()
[1] 0.4179786
> 
> s$r3 <- rng3
> rng4 <- s$r3
> rng4$nextDouble()
[1] 0.1000342
> 
> f <- rng4$nextDouble(.EVALUATE=FALSE)
> f()
[1] 0.8389872
> 
> 
> ####
> 
> 
> see <- "David"
> mkFunc1 <- function() {
+   see <- "B."
+   x <- "Milly"
+   print(environment())
+   r <- function(x1="Mack",x2="Bob") s %!% '
+     x1+" "+x2+" "+R.getS0("see")
+   '
+   r
+ }
> y1 <- mkFunc1()
<environment: 0x45be878>
> identical(y1("Lisa","Dahl"),"Lisa Dahl B.")
[1] TRUE
> 
> 
> mkFunc2 <- function() {
+   see <- "MMMM."
+   x <- "Milly"
+   r <- function(x="Mack",y="Bob") s %.!% '
+       x+" "+y+" "+R.getS0("see")
+   '
+   r
+ }
> y2 <- mkFunc2()
> identical(y2("Lisa","Dahl")$toString(),"Lisa Dahl MMMM.")
[1] TRUE
> gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 349726 18.7     592000 31.7   460000 24.6
Vcells 639787  4.9    1231266  9.4  1041796  8.0
> 
> 
> 
> func1 <- function() {
+   see <- "Knudsen"
+   y1("Lisa","Dahl")
+ }
> identical(func1(),"Lisa Dahl B.")
[1] TRUE
> 
> 
> ####
> 
> 
> # Realistic timing
> system.time({
+   e <- function(x=0,y=4L,name="dog") s %!% '
+     name + " " + ( x + y )
+   '
+   rscala:::scalaOptimize(e)
+ })
   user  system elapsed 
  0.000   0.000   0.404 
> 
> # Taking advantage of caching
> system.time({
+   f <- function(x=0,y=4L,name="dog") s %!% '
+     name + " " + ( x + y )
+   '
+   rscala:::scalaOptimize(f)
+ })
   user  system elapsed 
  0.000   0.000   0.002 
> 
> ####
> 
> nextDouble <- function(rng=s$null("scala.util.Random")) s %!% "rng.nextDouble()"
> 
> mkRNG1 <- function() s %.!% 'new scala.util.Random()'
> mkRNG2 <- function() s %.~% 'new scala.util.Random()'
> 
> rng1 <- mkRNG1()
> rng2 <- mkRNG2()
> 
> rng1$nextInt(10L)
[1] 5
> rng2$nextInt(10L)
[1] 3
> 
> str <- rng1$toString(.AS.REFERENCE=TRUE)
> str$length()
[1] 26
> 
> nd0 <- rng1$nextDouble(.EVALUATE=FALSE)
> nd1 <- function() s %!% 'R.cached("@{toString(rng1)}").asInstanceOf[@{rng1[[\'type\']]}].nextDouble()'
> nd1b <- rscala:::scalaOptimize(nd1)
> nd2 <- function() s %!% '@{rng2}.nextDouble()'
> nd2b <- rscala:::scalaOptimize(nd2)
> 
> library("microbenchmark")
> 
> microbenchmark(
+   runif(1),
+   rng1$nextDouble(),
+   rng2$nextDouble(),
+   nd0(),
+   nd1(),
+   nd1b(),
+   nd2(),
+   nd2b(),
+   times=500
+ )
Unit: microseconds
              expr      min        lq       mean    median        uq        max
          runif(1)    1.528   10.5905   11.85741   12.5770   13.8140    103.767
 rng1$nextDouble() 1524.569 2640.7660 4586.11583 2816.5660 3060.0530  74854.392
 rng2$nextDouble() 1436.181 2479.0240 4979.25290 2643.3335 2833.4255 464188.619
             nd0()  285.682  505.7020 1029.51425  566.5810  621.0220  37766.606
             nd1() 1416.598 2441.2460 4638.44144 2620.6300 2830.1230  84467.703
            nd1b()  291.167  515.0850  936.25197  571.1795  623.2355  33675.103
             nd2() 1309.308 2281.5940 4211.68623 2463.6715 2719.8120 130774.110
            nd2b()  283.662  503.9835 1191.09430  560.9205  602.9850  78254.951
 neval
   500
   500
   500
   500
   500
   500
   500
   500
> 
> ####
> 
> f <- function(x=4) {
+   if ( x < 0 ) stop("'x' must be positive")
+   if ( x == 0 ) x <- 10
+   s %!% '2*x'
+ }
> 
> f(4)
[1] 8
> tryCatch(f(-3), error=function(e) e)
<simpleError in f(-3): 'x' must be positive>
> f(0)
[1] 20
> 
> g <- rscala:::scalaOptimize(f)
> g(4)
[1] 8
> g(-3)     ## Note that no error because R code as been optimized away!
[1] -6
> g(0)      ## And we don't get the special case when x==0.
[1] 0
> 
> h <- function(x=4) {
+   if ( x < 0 ) stop("'x' must be positive")
+   if ( x == 0 ) x <- 10
+   s %~% '2*R.getD0("x")'
+ }
> 
> h(4)
[1] 8
> tryCatch(h(-3), error=function(e) e)
<simpleError in h(-3): 'x' must be positive>
> h(0)
[1] 20
> 
> microbenchmark(
+   f(4),
+   g(4),
+   h(4),        # h is *slow* and it has the memory leak inherent in Scala's REPL.
+   times=100)
Unit: microseconds
 expr       min         lq       mean      median         uq       max neval
 f(4)  1463.577   2500.490   3140.066   2656.0940   2830.419  20700.55   100
 g(4)   434.867    718.903   1834.588    804.1685    942.323  23579.87   100
 h(4) 76312.681 143489.372 208574.019 199493.3375 257928.484 461535.54   100
> 
> microbenchmark(
+   f(4),        
+   g(4),        # g is faster, but you lose the checking and special behavior.
+   times=1000)
Unit: microseconds
 expr      min        lq      mean   median       uq      max neval
 f(4) 1341.144 1824.0695 3520.8376 2397.537 2737.980 85976.40  1000
 g(4)  341.907  480.4895  946.7393  692.290  824.715 39191.54  1000
> 
> 
> 
> 
> ####
> 
> s$.scala.util.Random$nextDouble()
[1] 0.1471963
> m <- s$.scala.util.Random$new(342L,.EVALUATE=FALSE)
> m(23436)$nextDouble()
[1] 0.8011135
> m(63502)$nextDouble()
[1] 0.1435077
> m(93222)$nextDouble()
[1] 0.4889048
> m(93222)$nextDouble()
[1] 0.4889048
> 
> n <- m(5)$nextDouble(.EVALUATE=FALSE)
> n()
[1] 0.7305199
> n()
[1] 0.08825841
> n()
[1] 0.4889045
> 
> s$'.Array[Int]'$new(5L)
[1] 0 0 0 0 0
> 
> ####
> 
> s$a <- 1:10
> a <- s$.a
> a$apply(3L)
[1] 4
> 
> s$.scala.util.Random$nextDouble()
[1] 0.3933107
> s$.scala.util.Random$nextDouble()
[1] 0.1724944
> 
> s %@% 'import scala.util.Random'
> s$.Random$nextDouble()
[1] 0.6923998
> 
> a <- function() s %!% 'Random.nextDouble'
> a()
[1] 0.9513569
> 
> a <- s$.scala.util.Random
> a$nextDouble()
[1] 0.7863467
> 
> b <- ( function() s %!% 'scala.util.Random' )()
> b$nextDouble()
[1] 0.2851647
> 
> microbenchmark(
+   a$nextDouble(),
+   b$nextDouble(),
+   times=1000
+   )
Unit: milliseconds
           expr      min       lq     mean   median       uq      max neval
 a$nextDouble() 1.320924 1.922327 2.706884 2.497280 2.698321 34.60188  1000
 b$nextDouble() 1.418316 2.117277 2.992515 2.677215 2.885250 76.54087  1000
>   
> 
> ####
> 
> f <- function(x=NULL, wantNull=TRUE) s %.!% '
+   val r = R.getReference(x)
+   if ( wantNull ) null else r
+ '
> 
> a <- f(1:10, FALSE)
> a$name()
[1] "DkzS87Pt"
> 
> g <- function(func=NULL,y=scalaNull("PersistentReference")) s %!% '
+   R.invoke(func,y)
+ '
> 
> g(print, a)
 [1]  1  2  3  4  5  6  7  8  9 10
> 
> 
> ####
> 
> f <- function(x=scalaNull("(Int,Int)")) s %!% 'x._1 + x._2'
> g <- s %~% "(300,400)"
> f(g)
[1] 700
> f(s %.~% "(30,40)")
[1] 70
> 
> f2 <- function() s %~% 'println("Yes")'
> f2()
> capture.output(f2())
character(0)
> 
> a <- s %.~% "(300,234)"
> f1 <- function(x=scalaNull("(Int,Int)"),y=numeric()) s %!% 'x._1 + x._2 + y.sum'
> f1(a,c(2,3,4,6))
[1] 549
> 
> f1 <- function(x=scalaNull("(Int,Int)"),y=scalaNull("Array[Double]")) s %!% 'x._1 + x._2 + y.sum'
> b <- s %.~% "Array[Double](2,3,4,5)"
> f1(a,b)
[1] 548
> 
> ####
> 
> (function() s %!% 'println("Yes")')()
> (function() s %!% '0')()
[1] 0
> (function() s %!% 'null')()
> 
> ####
> 
> tryCatch((function() s %!% 'a+b')(),error = function(e) e)
<simpleError in scalaEval(interpreter, snippet, workspace): Error in evaluation.>
> tryCatch((function() s %!% 'a+')(),error = function(e) e)
<simpleError in scalaEval(interpreter, snippet, workspace): Error in evaluation.>
> tryCatch((function() s %!% 'import org.asdfad')(),error = function(e) {e})
<simpleError in scalaEval(interpreter, snippet, workspace): Error in evaluation.>
> tryCatch((function() s %!% 'throw new RuntimeException()')(),error = function(e) {e})
<simpleError in doTryCatch(return(expr), name, parentenv, handler): Invocation error.>
> s %~% "5+6"   # Everything's still okay!
[1] 11
> 
> 
