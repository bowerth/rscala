%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{rscala: Integration of R and Scala}

%% Parts to write:
%%    * Abstract
%%    * Introduction
%%    * Bootstrap example
%%    * MCMC example
%%    * Comparison to other software
%%    * Conclusion

\documentclass[article]{jss}

\let\hlesc\hlstd \let\hlpps\hlstd \let\hllin\hlstd \let\hlslc\hlcom

\usepackage{lscape}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{booktabs}
\usepackage{paralist}
\usepackage{thumbpdf}
\usepackage[11pt]{moresize}
\usepackage{alltt}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage[T1]{fontenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
%\overfullrule=3mm

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{xspace}

\newcommand{\rscala}{\pkg{rscala}\xspace}
\newcommand{\jvmr}{\pkg{jvmr}\xspace}
\newcommand{\rJava}{\pkg{rJava}\xspace}
\newcommand{\Rserve}{\pkg{Rserve}\xspace}
\newcommand{\Rcpp}{\pkg{Rcpp}\xspace}
\newcommand{\inline}{\pkg{Inline}\xspace}
\newcommand{\R}{\proglang{R}\xspace}
\newcommand{\Rscript}{\proglang{Rscript}\xspace}
\newcommand{\C}{\proglang{C}\xspace}
\newcommand{\Python}{\proglang{Python}\xspace}
\newcommand{\Csharp}{\proglang{C\#}\xspace}
\newcommand{\Ruby}{\proglang{Ruby}\xspace}
\newcommand{\Cpp}{\proglang{C++}\xspace}
\newcommand{\Scala}{\proglang{Scala}\xspace}
\newcommand{\Java}{\proglang{Java}\xspace}
\newcommand{\Fortran}{\proglang{Fortran}\xspace}
\newcommand{\BeanShell}{\pkg{BeanShell}\xspace}
\newcommand{\todo}[1]{\textbf{\textit{\colorbox{yellow}{\color{red}{TODO} \ldots #1}}}}

%% almost as usual
\author{David B.\ Dahl\\Brigham Young University}
\title{\textit{\Large Under Review\\\footnotesize Software Version: 2.3.0,\ \ Document Date: 2017-08-16}\\\vspace{5ex} Integration of \R and \Scala Using \rscala}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{David B. Dahl} %% comma-separated
\Plaintitle{rscala: Integration of R and Scala} %% without formatting
\Shorttitle{\rscala: Integration of \R and \Scala} %% a short title (if necessary)

%% an abstract and keywords
\Abstract{
The \rscala package is a simple, two-way bridge between \R and \Scala. \Scala
classes can be instantiated from \R, and both \Scala and \Java methods can be
called as native \R functions.  Furthermore, arbitrary \Scala code can be
executed on-the-fly from within \R, inline \Scala functions can be defined,
and callbacks to \R are supported.  Finally, \rscala also enables \R code to
be embedded within a \Scala application.  The \rscala package is available on
CRAN and requires no special installations or configurations of \R or \Scala.
}

\Keywords{embedded interpreter, \Java, Java Virtual Machine, JVM, \R, \Scala}
\Plainkeywords{embedded interpreter, Java, Java Virtual Machine, JVM, R, Scala} %% without formatting

%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{50}
%% \Issue{9}
%% \Month{June}
%% \Year{2012}
\Submitdate{2017-08-16}
%% \Acceptdate{2012-06-04}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  David B.\ Dahl\\
  Professor\\ % and Associate Department Chair\\
  Department of Statistics\\
  Brigham Young University \\
  223 TMCB\\
  Provo, UT 84602\\
  E-mail: \email{dahl@stat.byu.edu}\\
  URL: \url{https://dahl.byu.edu}\\
}

%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/512/507-7103
%% Fax: +43/512/507-2851

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \renewcommand{\textfraction}{0.05}
%% \renewcommand{\topfraction}{0.95}
%% \renewcommand{\bottomfraction}{0.95}
%% \renewcommand{\floatpagefraction}{0.35}
%% \setcounter{totalnumber}{5}

\begin{document}

% Fix poorly formatted tilde.
\newcommand{\mytilde}{\lower.6ex\hbox{\char`\~}}
<<setup, include=FALSE>>=
library("knitr")
opts_chunk$set(fig.path='figure/latex-', cache.path='cache/latex-', cache=TRUE, size="small", out.columns=84, fig.align='center', fig.show='hold')
options(formatR.arrow=TRUE, width=90)
hook_source <- knit_hooks$get('source')
knit_hooks$set(source = function(x, options) {
  txt <- hook_source(x, options)
  # extend the default source hook
  gsub('~', '\\\\mytilde', txt)
})
#hook_output = knit_hooks$get('output')
#knit_hooks$set(output = function(x, options) {
#  if (!is.null(n <- options$out.lines)) {
#    x = unlist(strsplit(x, '\n'))
#    if (length(x) > n) {
#      # truncate the output
#      x = c(head(x, n), '....\n')
#    }
#    x = paste(x, collapse = '\n') # paste first n lines together
#  }
#  if (!is.null(n <- options$out.columns)) {
#    x = unlist(strsplit(x, '\n'))
#    probs <- nchar(x)>options$out.columns
#    x[probs] <- paste(substr(x[probs],1,options$out.columns-3), '...', sep="")
#    x = paste(x, collapse = '\n') # paste first n lines together
#  }
#  hook_output(x, options)
#})
@

%% include your article here, just as usual
%% Note that you should use the \pkg{}, \proglang{} and \code{} commands.

\section{Introduction}
\label{introduction}

\Scala  \citep{scala} is a general-purpose, statically-typed programming
language that supports both object-oriented and functional programming
paradigms.  The integration of these two paradigms allows a developer to
choose the best paradigm for a given task.  Code is generally concise, thanks
in part to type inference.  Martin Odersky, a professor at EPFL in Switzerland,
is the primary architect of \Scala. Previously, Odersky worked for Sun Microsystems
where he developed the current generation of the \Java \citep{java} compiler.
It is said that \Scala's design is influenced by criticisms of \Java though
a high level of interoperability between \Scala and \Java is maintained.
Indeed, \Scala source code compiles to \Java bytecode and runs on the Java
Virtual Machine (JVM).  Typesafe, a company co-founded by Odersky,
provides an open source platform centered around \Scala and makes its money
providing training, consulting, and commercial support for the platform.

\R \citep{r} is a scripting language and environment developed by statisticians
for statistical computing and graphics.  \R
has many contributors and a large base of statistically-oriented users.  \Scala
and \R each have distinct strengths and weaknesses.  We believe that \Scala
deserves consideration when looking for a general-purpose programming language
to complement \R, but advocating \Scala for statistical computing is beyond
the scope of this paper.  Instead, this paper introduces our \rscala
\citep{rscala} package to those that are already somewhat familiar with \R and
\Scala.  The package allows users to seamlessly incorporate \R and \Scala (or
\Java) code in one program and utilize each language's respective strengths
(including libraries, methods, speed, graphics, etc.).  Specifically, \rscala
provides a two-way bridge between \R and \Scala, enabling \R to execute
\Scala code and vice versa.  \Scala and \Java classes can be instantiated,
methods of \Scala and \Java classes can be called directly, inline \Scala
functions can be defined, and arbitrary \Scala code can be executed on-the-fly
from within \R.  Callbacks from \Scala into the original \R interpreter are
also supported.  Conversely, arbitrary \R code can be evaluated from within a \Scala
application through an embedded \R interpreter.

Thus, the \rscala package allows \R developers to reuse \Scala code and apply
their \Scala skills to make \R extensions.  On the other hand, \rscala allows
\Scala developers to make use of \R's broad array of data analysis and graphing
capabilities from within a \Scala application.  The \rscala package is intended
to provide this bridge to those who have an interest in both \Scala and \R.
This is not unlike what has already been done with \R and other languages.
Although largely transparent to the user, much of \R's core is implemented with
calls to \C, \Cpp, and \Fortran code.  These low-level languages provide more
flexibility in memory management and compile to code that executes relatively
quickly.  The \rJava \citep{rjava} package extends this support to precompiled
\Java code.  While results vary depending on the algorithm and testing
methodology, it is generally recognized that well-designed \C, \Cpp, and
\Fortran code will execute faster and use less memory than \Java.
Nevertheless, \Java arguably has several advantages and has attracted a
substantial developer base.  The \rJava package allows developers to use
existing \Java code and to apply their \Java skills to make \R extensions.  The
\rscala package aims to do for \Scala what \rJava has done for \Java.

The paper is organized as follows.  Section \ref{usage} provides a general
usage guide to get users started quickly.  Technical details of the package
implementation are discussed in Section \ref{implementation}.  Comparisons to
other software, including numerical benchmarks, are provided in Section
\ref{comparisons}.  Section \ref{caseStudies} looks at two case studies using
the \rscala package.  We conclude with future work in Section \ref{conclusion}.

\section[Accessing Scala in R]{Accessing \Scala in \R}
\label{usage}

This section provides a guide to accessing
\Scala from \R.  Those interested in the reverse --- accessing \R from \Scala
--- will also benefit from understanding the ideas presented here.

\subsection[Package and Scala installation]{Package and \Scala installation}

The \rscala package is available on the Comprehensive \R Archive Network (CRAN)
and can be installed by executing the following \R expression.

<<installPackage,eval=FALSE>>=
install.packages('rscala')
@

The \rscala package requires a \Scala installation in the 2.10.x, 2.11.x, or
2.12.x series.  A convenience function,
\code{rscala::scalaInstall()}, is provided to download and install \Scala in the user's
home directory under the \code{.rscala} directory. Because this is a user-level
installation, administrator privileges are not required.

Alternatively, system administrators can install \Scala using their operating
system's software management system (e.g., ``\code{sudo apt install scala}'' on
Debian/Ubuntu based systems), or users can install \Scala manually as described on the
\Scala webpage.

\subsection[Instantiating a Scala interpreter in R]{Instantiating a \Scala interpreter in \R}

Load and attach the \rscala package in an \R session with the \code{library} function:

<<library>>=
library('rscala')
@

Create a \Scala instance using the \code{scala} function:

<<instantiateInterpreter,eval=FALSE>>=
s <- scala()
@

<<instantiateInterpreterHidden,eval=TRUE,include=FALSE>>=
set.seed(2234)
s <- scala(serialize.output=TRUE)
s %@% 'scala.util.Random.setSeed(3242)'
@

Information on the \Scala instance \code{s} is available using:

<<scalaInfo,eval=FALSE>>=
scalaInfo(s)
@

Alternatively, details on the search for a suitable \Scala installation are shown
using:

<<scalaInfo2,eval=FALSE>>=
scalaInfo(verbose=TRUE)
@

The \code{scala} function includes parameters to specify which \Scala
installation to use, the class path, whether matrices are in row-major or
column-major order, and several other settings. Details on this and all other
functions are provided in the \R documentation for the package (e.g.,
\code{help(scala)}).

A \Scala session
is only valid during the \R session in which it is created and cannot be saved
and restored through, for example, the \code{save} and \code{load} functions.
Multiple \Scala instances can be created in the same \R session.
Each \Scala instance runs independently with its own memory, classpath,
history, etc.

The \R to \Scala bridge is not thread-safe, so multiple \R processes/threads should not access the same \Scala
instance simultaneously.

\subsection[Calling Scala code from R]{Calling \Scala code from \R}

\subsubsection[Evaluating Scala snippets]{Evaluating \Scala snippets}

Snippets of \Scala code can be compiled and executed within an \R session using several
operators.  The most basic operator is \code{\%@\%} which evaluates \Scala code and returns \code{NULL}.
Consider, for example,
computing the binomial coefficient ${10 \choose 3} = \prod_{i=1}^3 (10-i+1)/i$.

<<evaluateScalaCodeSimple>>=
s %@% '
  val c_10_3 = (1 to 3).map( i => {
    (10-i+1) / i.toDouble
  }).product.toInt
'
@

This result is available in subsequent \Scala expressions as demonstrated below.

<<evaluateScalaCodeSimple3>>=
s %@% 'print("10 choose 3 is " + c_10_3 + ".")'
@

Notice the side effect of printing \code{120} to the console.
The behavior for console printing is controlled by the arguments
\code{serialize.output}, \code{stdout}, and \code{stderr} of the \code{scala}
function.  Default values depend on the operating system and are set such that
console output is displayed in typical environments.

\Scala snippets can also be evaluated with the \code{\%\mytilde\%}
operator.  Whereas \code{\%@\%} always returns \code{NULL}, \code{\%\mytilde\%} returns the result of the last expression in the \Scala snippet.

<<evaluateScalaCodeSimple2>>=
tenChooseThree <- s %~% '(1 to 3).map( i => (10-i+1) / i.toDouble ).product'
tenChooseThree == choose(10,3)
@

\subsubsection{String interpolation}

The \rscala package has string interpolation for
dynamic code snippets. \R code placed between ``\code{@\{}'' and ``\code{\}}''
in a \Scala snippet is evaluated and replaced by the string representation of
the \R expression's value before the \Scala snippet is executed. The \R code is executed in the same environment (i.e., scope) as
the evaluation request. A snippet can contain any number of \code{@\{...\}}
expressions.  For example,

<<evaluateScalaCodeStringInterpolation>>=
n <- 10
k <- 3
label <- "number of threesomes among ten people"
s %@% '
  val count = (1 to @{k}).foldLeft(1) { (prod,i) => prod * (@{n}-i+1)/i }
  println("The @{label} is " + count + ".")
'
@

Care is needed when using string interpolation because it relies on
\R's character representation on an \R expression.  One might be surprised, for
example, that the second expression in the next example is false. This is because \code{@\{tenChooseThree\^{}20\}} is replaced by a string literal
(i.e., \code{6.191736e+20}, which is slightly different than the calculated value.

<<evaluateScalaCodeInterpolationError>>=
s %~% 'math.pow(count, 20) == @{tenChooseThree^20}'
@

\subsubsection{Primitive and copyable types}

A \Scala result of class \code{Byte}, \code{Int}, \code{Double},
\code{Boolean}, or \code{String} is passed back to \R as a length-one vector of
raw, integer, double, logical, or character, respectively.  We refer to these
as the \emph{primitive types} supported by the \rscala package. Further, \Scala
arrays and rectangular arrays of arrays of the primitive types are passed to \R
as vectors and matrices of the equivalent \R types.  We call \emph{copyable
types} those types that are primitives, arrays of primitives, and rectangular
arrays of arrays of the primitive types.  The name emphasizes the fact that
these data structures are serialized and copied between
\Scala and \R. This may be a costly exercise for large data
structures.

The code below produces a 2x5 matrix in \R.
If the \code{row.major} argument of the \code{scala} function is changed to
\code{FALSE} when defining the \Scala instance \code{s}, the code produces a
5x2 matrix instead.

<<evaluateScalaCodeVector>>=
s %~% 'Array.fill(2)(Array.fill(5)(scala.util.Random.nextDouble))'
@

Table \ref{mappings} shows the mapping of primitive \Scala and \R types using
code examples.

\begin{table}[tb]
\scriptsize
\centering
\begin{tabular}{lll}
\toprule
     \textbf{Primitives} & \textbf{Vectors / Arrays} & \textbf{Matrices / Rectangular Arrays of Arrays} \\
\midrule
\noalign{\vspace{2ex}}
\code{a <- as.raw(3)} & \code{f <- as.raw(c(1, 2))} & \code{k <- matrix(as.raw(c(1, 2)), nrow=2)} \\
\code{val a = 3.toByte} & \code{val f = Array(1.toByte, 2.toByte)} & \code{val k = Array(Array(1.toByte), Array(2.toByte))} \\
\noalign{\vspace{4ex}}
\code{b <- TRUE} & \code{g <- c(TRUE, FALSE)} & \code{l <- matrix(c(TRUE, FALSE), nrow=2)} \\
\code{val b = true} & \code{val g = Array(true, false)} & \code{val l = Array(Array(true), Array(false))} \\
\noalign{\vspace{4ex}}
 \code{c <- 1L} & \code{h <- c(1L, 2L, 3L)} & \code{m <- matrix(c(1L, 2L), nrow=2)} \\
 \code{val c = 1} & \code{val h = Array(1, 2, 3)} & \code{val m = Array(Array(1), Array(2))} \\
\noalign{\vspace{4ex}}
 \code{d <- 1.0} & \code{i <- c(1.0, 2.0, 3.0)} & \code{n <- matrix(c(1.0, 2.0), nrow=2)} \\
 \code{val d = 1.0} & \code{val i = Array(1.0, 2.0, 3.0)} & \code{val n = Array(Array(1.0), Array(2.0))} \\
\noalign{\vspace{4ex}}
 \code{e <- "a"} & \code{j <- c("a", "b", "c")} & \code{o <- matrix(c("a", "b"), nrow=2)} \\
 \code{val e = "a"} & \code{val j = Array("a", "b", "c")} & \code{val o = Array(Array("a"), Array("b"))} \\
\noalign{\vspace{2ex}}
\bottomrule
\end{tabular}
\caption{\Scala values of type \code{Byte}, \code{Int}, \code{Double},
\code{Boolean}, or \code{String} (labeled \emph{primitives}), as well as arrays
and rectangular arrays of arrays of these types are copied from \Scala to \R as
length-one vectors, vectors, and matrices of the equivalent \R types.  These are
called \emph{copyable types}.  Each cell in the table contains two lines: an \R
expression (top) and the equivalent \Scala expression (bottom) with the same
identifier.  The matrix examples assume that the \code{scala} function is
called with \code{row.major=TRUE}.}
\label{mappings}
\end{table}

\subsubsection[Scala references]{\Scala references}

If the result of a \Scala expression is not a copyable type, then the
\code{\%\mytilde\%} operator will return a reference to a \Scala object that
can be used in subsequent evaluations.  If a \Scala reference is desired, even
when working with copyable types, use the \code{\%.\mytilde\%} operator.

In the next example, an instance of the class \code{scala.util.Random} is
created and, because the result is not a copyable type, a \Scala reference is
returned.  Second, a \Scala reference to an array of integers is returned,
despite the fact this is a copyable type, because the \code{\%.\mytilde\%}
operator is used.

<<evaluateScalaCodeReference>>=
rng <- s %~% 'new scala.util.Random()'
rng

oneToTenReference <- s %.~% 'Array.range(1,11)'
oneToTenReference
@

% In the next example, a \Scala reference is used via string interpolation to
% call methods of \Scala objects:
% 
% \clearpage
% <<evaluateScalaCodeReferenceInterpolation>>=
% s %~% '
%   @{rng}.setSeed(24234)
%   @{rng}.nextDouble()
% '
% 
% s %~% '@{oneToTenReference}.sum'
% @

\subsubsection{Getting and Setting Variables}

Values of copyable types and \Scala references can
be obtained as the result of evaluating a \Scala expression using the
\code{\%\mytilde\%} and \code{\%.\mytilde\%} operators.  The expression can be
very complex or, as in the examples below, merely the name of a \Scala
identifier, e.g.:

<<gettingUsingDollarSign1>>=
s %@% 'val fibSeq = Array[Double](0, 1, 1, 2, 3, 5, 8, 13, 21)'
fibSeqAsDouble  <- s %~%  'fibSeq'
fibSeqReference <- s %.~% 'fibSeq'
@

\Scala values can also be obtained using the \code{\$} operator and the identifier name.
For example, the following both provide equivelent definitions for 
\code{fibSeqAsDouble} above.

<<gettingUsingDollarSign2>>=
fibSeqAsDouble <- s$fibSeq
fibSeqAsDouble <- s$val('fibSeq')
@

Likewise, an equivalent definition for \code{fibSeqReference} is:

<<gettingUsingDollarSign3>>=
fibSeqReference <- s$.val('fibSeq')
@

Note that \code{val} is a reserved word in \Scala and therefore using
\code{val} and \code{.val} here is guaranteed to not conflict with any variable names in \Scala.
While somewhat more verbose, the argument to \code{val} and \code{.val} can be a literal or a variables, whereas the \code{\$} operator requires a literal.

Conversely, values of copyable types and \Scala references may be set in the
\Scala session using assignment with the \code{\$} operator, e.g.:

<<gettingUsingDollarSign4>>=
s$fibSeq <- c(0, 1, 1, 2, 3, 5, 8, 13, 21)
s$copyOfFibSeqReference <- fibSeqReference
@

\subsubsection{Instantiating objects}

\Scala objects can be instantiated in three ways.  For example, the following
are functionally equivalent ways of creating
a new instance of \code{scala.util.Random}
with the seed set at \code{123}:

<<evaluateScalaCodeInstantiate>>=
seed <- 123L
rng <- s %.~% 'new scala.util.Random(@{seed})'
rng <- s$.scala.util.Random$new(seed)
rng <- s$do('scala.util.Random')$new(seed)
@

Each method differs in terms of flexibility, readability, and speed.  The first
is mostly \Scala code and therefore self-evident to a \Scala developer, but it
is the slowest and akward when arguments are not easily set with string
interpolation.  The second (using \code{s\$.}) is concise, fast, and flexible
in the arguments.  The last method (using \code{s\$do}) is also fast and
flexible but slightly awkward.  It has the added advanage, however, that the
class name can be a literal (as in this example) or a variable.  Note that
\code{do} is used here because it is a reserved words in \Scala and is
therefore guaranteed to not conflict with a variable name.

\subsubsection[Access methods and variables of Scala objects]{Access methods and variables of \Scala objects}

Taking inspiration from \rJava's ``high-level \code{\$} operator,'' methods
associated with \Scala references can be called directly using the \code{\$}
operator, as shown below.

<<evaluateScalaCodeReference2>>=
rng$setSeed(24234L)
rng$nextInt(10L)
oneToTenReference$sum()
@

If the result of a method call on a \Scala reference is not a copyable type, then
a reference to a \Scala object is returned.  If a \Scala reference is desired even
when working with copyable types,
add a final argument
\code{.AS.REFERENCE=TRUE}, e.g.,

<<evaluateScalaCodeReference3>>=
intReference <- rng$nextInt(10L, .AS.REFERENCE=TRUE)
@

The value of an instance variable may be accessed as if there was a method of the same name taking no arguments, e.g.,

<<evaluateScalaCodeReference1>>=
rng$self()
@

\subsubsection{Calling methods of singleton objects}

In constrast to \Java, \Scala classes do not have static variables or methods.
Equivalent functionality is provided by singleton objects in \Scala.
A companion object is a singleton object whose name is the same as a class.
Methods of singleton objects can be called in three ways.  For example, consider
the companion object \code{Array} to the class \code{Array}.  Its \code{range} method creates an array of
regularly-spaced elements.  The following three statements are all functionally
equivalent:

<<evaluateScalaCodeCompanion>>=
oneToTenReference <- s %.~% 'Array.range(1, 11)'
oneToTenReference <- s$.Array$range(1L, 11L, .AS.REFERENCE=TRUE)
oneToTenReference <- s$do('Array')$range(1L, 11L, .AS.REFERENCE=TRUE)
@

Again, as for instantiating objects, each functionally equivalent way has its advantages in terms of
flexibility, readability, and speed.

% \subsubsection[Discovering methods and variables of Scala objects]{Discovering methods and variables of \Scala objects}
% 
% \Scala provides the \code{scalap} executable to list the methods of classes and
% companion objects.  Its output is available directly in \R using the
% \code{scalap} function.  For example, \code{scalap(s, 'scala.util.Random')} and \code{scalap(rng)} both
% display the following.
% 
% <<scalap1, out.lines=5>>=
% scalap(rng)
% @
% 
% The \rscala package also provide rudimental tab-completion for method names of
% \Scala references.

\subsubsection[Method arguments, null references, and length-one vectors]{Method arguments, null references, and length-one vectors}

Arguments to a method of an object (as well as argument to \code{new})
can be copyable types and \Scala references.  To pass a null
reference of a particular type, use the \code{scalaNull} function.  For
example, \Java's \code{java.lang.System} has a static
\code{setProperties} method which
takes
a null reference to \code{java.util.Properties} 
to clear the system properties, e.g.:

<<nullAsArgument>>=
s$.java.lang.System$setProperties(scalaNull('java.util.Properties'))
@

\R has no scalar types but they are often used in \Scala.  As such,
length-one vectors have special symmatics.
In the \R expression
\code{rng\$nextInt(10L)}, the value \code{10L} is an integer vector of
length one in \R, but is passed to \Scala as \code{Int}, not \code{Array[Int]}.
This behavior is usually the natural and convenient behavior.  If, however, an \R
vector should always be passed as an array --- despite the fact that it might
be of length one --- wrap the vector in a call to the \code{I} function.  This ensures
that the vector is treated ``as is''.  For example, consider a singleton object with an
\code{apply} method that takes an array of any arbitrary type \code{T} and a value of type \code{T}, and sets every element of
the array to that value:

<<lengthOne>>=
setter <- s %.~% '
  object setter {
    def apply[T](x: Array[T], value: T) = x.indices.foreach { x(_) = value }
  }
  setter
'
@

When calling the \code{apply} method of the \code{setter} object, the first
argument must be an array.  Thus, if there is a potential that the \R vector is
length-one, it should be wrapped by the \code{I} function.  In the example
below, the first argument is wrapped by \code{I} and is therefore passed to \Scala as an
array.  The second argument is a length-one double vector in \R yet is treated
as a \code{Double} (instead of \code{Array[Double]}) because it is \emph{not}
wrapped by \code{I}:

<<lengthOne2>>=
arr <- s %.~% 'Array(math.Pi, math.E)'
arr$mkString("<", ", ", ">")
setter$apply(I(arr), 3)
arr$mkString("<", ", ", ">")
@

\subsubsection[The apply and update methods]{The \code{apply} and \code{update} methods}

\Scala users are aware of the ``compiler magic'' that injects calls to the
\code{apply} method of objects when no method is specified.  In the \rscala
package, this works for \Scala snippets, but the \code{apply} method must be
specified explicitly when using the \code{\$} operator.  For example, consider
an array of the starting elements of the Fibonacci sequence and the following
functionally-equivalent expressions:

<<evaluateScalaCodeApply>>=
fibSeqAsInt <- s %~% 'Array(0, 1, 1, 2, 3, 5, 8, 13, 21)'
fibSeqAsInt <- s %~% 'Array.apply(0, 1, 1, 2, 3, 5, 8, 13, 21)'
fibSeqAsInt <- s$.Array$apply(0L, 1L, 1L, 2L, 3L, 5L, 8L, 13L, 21L)
fibSeqAsInt <- s$do('Array')$apply(0L, 1L, 1L, 2L, 3L, 5L, 8L, 13L, 21L)
@

Likewise, the \code{update} method is automatically injected by the \Scala
compiler when appropriate, but must be explicit when using the \code{\$}
operator.  Consider, for example, assigning the value of $\pi$ to the second
element of the array using the following.  The last four statements are
functionally equivalent.

<<evaluateScalaCodeUpdate>>=
s %@% 'val fibSeq = Array[Double](0, 1, 1, 2, 3, 5, 8, 13, 21)'
fibSeqReference <- s %.~% 'fibSeq'
s %@% 'fibSeq(1) = math.Pi'
s$.fibSeq$update(1L, pi)
s$do('fibSeq')$update(1L, pi)
fibSeqReference$update(1L, pi)
@

The previous example also illustrates that the \code{s\$.} and
\code{s\$do} notations --- which were first introduced for object
instantiation and calling methods of singleton objects --- can also be used for
existing \Scala values (e.g., \code{fibSeq} above).

\subsubsection{Quoting method names}

\Scala has type parameterization which is similar but arguably more
advanced than generics in \Java and templates in \Cpp.  In many instances, the
\Scala compiler infers the type parameter, but the user may need or want to
explicitly provide it.  When using the \code{\$} operator, the method name with
its type parameter should be quoted to prevent parsing errors in \R.  The
following expressions are functionally equivalent.

<<evaluateScalaCodeApplyWithQuote>>=
fibSeqAsDouble <- s %~% 'Array[Double](0, 1, 1, 2, 3, 5, 8, 13, 21)'
fibSeqAsDouble <- s %~% 'Array.apply[Double](0, 1, 1, 2, 3, 5, 8, 13, 21)'
fibSeqAsDouble <- s$.Array$'apply[Double]'(0L, 1L, 1L, 2L, 3L, 5L, 8L, 13L, 21L)
fibSeqAsDouble <- s$do('Array')$'apply[Double]'(0L, 1L, 1L, 2L, 3L, 5L, 8L, 13L, 21L)
@

Note the quotes around \code{apply[Double]} used in the last two expressions.
Of course, since \R treats numeric literals as doubles, the simplest way to get
the same result from the \code{apply} method of the \code{Array} companion
object is:

<<evaluateScalaCodeApplyWithQuoteSimple>>=
fibSeqAsDouble <- s$.Array$apply(0, 1, 1, 2, 3, 5, 8, 13, 21)
@

Likewise, names of \Scala methods may not be valid identifiers in \R and may
also need to be quoted to avoid parsing errors in R.  For example, note that
the method \code{:+} is quoted in the example below:

<<quoteWhenNecessary>>=
list <- s$.List$apply(1L, 2L, 3L)
augmentedList <- list$':+'(100L)
paste0(augmentedList$toString(), " now contains 100.")
@

% \subsubsection[Interfacing with Java]{Interfacing with \Java}
% 
% \Scala runs on the Java Virtual Machine and since it supports instantiating
% \Java classes and calling object and static methods, the \rscala package
% automatically provides this support as well.  For example, the example below
% finds the system's time zone through a chain of calls using the standard \Java
% library:
% 
% <<javaVersion>>=
% s$.java.util.TimeZone$getDefault()$getDisplayName()
% @

\subsubsection[Defining inline Scala functions]{Defining inline \Scala functions}
\label{inline}

In addition to calling previously-compiled \Scala methods, the \rscala package
enables \Scala functions to be defined \emph{within} an \R session.  The
associated \Scala code is compiled on-the-fly and cached for subsequent
evaluation in the \R session.  This feature is inspired by the 
\Rcpp and \pkg{inline} \R packages for \C, \Cpp, and \Fortran.  We do not
recommend that long, complicated algorithms be implemented as inline \Scala
functions, but these functions can be helpful for implementing small tasks or
writing dynamic code to interface with existing \Scala code.

To demonstrate \Scala functions, consider computing the number of partitions
of $n$ items (i.e., the Bell number \citep{bell} of $n$).  This
number is often used for finite mixture models and random partition
models (e.g., \citet{casella2014}).  First, consider this \R implementation of
a computationally- and memory-efficient algorithm based on the Bell triangle (also
known as the Aitken's array or the Peirce triangle):

<<bellUsingR>>=
bell.version1 <- function(n=1, format=c("character","integer","double","log")[3]) {
  if ( n <= 0 ) stop("'n' must be at least 1.")
  if ( n == 1 ) return(1)
  r1 <- r2 <- numeric(n)
  r1[1] <- 1
  for ( k in 2:n ) {
    r2[1] <- r1[k-1]
    for ( i in 2:k ) r2[i] <- r1[i-1] + r2[i-1]
    r1 <- r2
  }
  value <- r2[n]
  if ( format == "character" ) sprintf("%0.0f", value)
  else if ( format == "integer" ) as.integer(value)
  else if ( format == "double" ) value
  else if ( format == "log" ) log(value)
}
@

The \code{bell.version1} function performs calculations based on
double-precision floating-point arithmetic and provides \emph{exact} answers
for $n \le 22$, gives \emph{approximate} answers for $22 < n \le 218$, and
overflows for $n > 218$.  Notice the \code{format} argument that controls how
the results are provided.  Unfortunately, $n \le 218$ is quite limiting because
sample sizes are often much larger in practice.  The following \Scala function,
defined within the \R session, implements the same algorithm but allows
$n$ to be greater than $218$.

<<bellUsingScala>>=
bell.version2 <- function(n=1L, format=c("character","integer","double","log")[3]) {
  if ( n <= 0 ) stop("'n' must be at least 1.")
  s %!% '
    var r1 = new Array[BigInt](n)
    var r2 = new Array[BigInt](n)
    r1(0) = BigInt(1)
    for ( k <- 1 until n ) {
      r2(0) = r1(k-1)
      for ( i <- 1 to k ) r2(i) = r1(i-1) + r2(i-1)
      val tmp = r1; r1 = r2; r2 = tmp
    }
    val value = r1(n-1)
    format match {
      case "character" => value.toString
      case "integer" => value.toInt
      case "double" => value.toDouble
      case "log" =>
        val blex = value.bitLength - 1022
        if ( blex > 0 ) math.log( (value >> blex).toDouble ) + blex * math.log(2)
        else math.log(value.toDouble)
    }
  '
}
@

There are a few minor differences between the \R and \Scala versions (e.g., \Scala uses zero-based indexing of
arrays, syntactic differences between \R and \Scala, and the
\Scala version avoids the copying found in the \R version), but the practical
difference is that \code{bell.version2} uses infinite precision integer
arithmetic based on \Scala's builtin \code{BigInt} class.  Overflow
still occurs when transfering to \R using \code{format="integer"} or \code{format="double"},
but there is no overflow for almost any $n$ when \code{format="log"},
and the exact value is returned when \code{format="character"}.  The
sample code below shows that the \Scala function produces exact integer calculations for
large $n$, and that subsequent calls to the function are faster than
the first call.

<<callBellUsingScala>>=
system.time( bigNumber <- bell.version2(500, format="character") )
cat(paste(strsplit(bigNumber, "(?<=.{80})", perl = TRUE)[[1]], collapse="\n"), "\n")
system.time( bigNumber <- bell.version2(500, format="character") )
@

Taking a closer look at the definition of the \code{bell.version2} function,
notice that the last expression in the function is \code{s \%!\% '...'}, where
\code{s} is the \Scala instance and
\code{'...'} represents the multiline \Scala snippet.  The effect of the
\code{\%!\%} operator is two-fold: i.~it automatically makes the arguments of the
enclosing function (namely, \code{n} and \code{format}) available in the \Scala
snippet, and ii.~it caches the on-the-fly compilation of the \Scala snippet to
substantially improve speed for subsequent calls to \code{bell.version2}.  The \code{\%!\%}
operator returns a copyable type or a \Scala
reference if the result is not a copyable type.  The \code{\%.!\%} operator
is identical except that it always returns a \Scala reference.

The consumer of a \Scala function does not need to know that the implementation
is written in \Scala.  There are a few considerations, however, for the
programmer of a \Scala function.  First, the last expression of a \Scala
function should always use \code{\%!\%} or
\code{\%.!\%}.  Second, the arguments to \Scala functions can be
copyable types, \Scala references, or \code{NULL}, where \code{NULL} is used to
indicate arbitrary \R objects that will not be converted to \Scala values but can be used in \R code.  Third, default values must be provided for
every argument, thereby indicating to \rscala the argument's type.  If the
user passes arguments of different types than those indicated by the default
values, they are cast to the expected type.  The \code{scalaNull} function can be
used to specify an argument's \Scala type without instantiating an object
of that class.  For example, an argument to a \Scala function might be \code{rng
= scalaNull("scala.util.Random")}, indicating that the argument should be an
object of class \code{scala.util.Random}.

\subsubsection[Callbacks into R from embedded Scala]{Callbacks into \R from embedded \Scala}

When a \Scala instance is created with the \code{scala} function, an instance
of the \Scala class \code{org.ddahl.rscala.RClient} is bound to the identifier
\code{R}.  This object provides access to the \R session from within the \Scala
instance.  The \code{RClient} class is thread-safe.  Its source code and Scaladoc
are located on GitHub:
\url{https://github.com/dbdahl/rscala/}.

To assign a value to a variable in
the \R session from \Scala, use the \code{set} method:

<<setInScala>>=
s %@% '
  R.set("zone", java.util.TimeZone.getDefault.getDisplayName)
  R.set("atLeast8", scala.util.Properties.isJavaAtLeast("1.8"))
'
zone
atLeast8
@

\R variables can be accessed in \Scala using several methods.  The
first method is \code{get}. It returns a \code{Tuple2} where the first member
is the \R variable's value (statically typed as \code{Any}) and the second is a \code{String} identifying the resulting \Scala type.
Consider the example below in
which the value of the \R variable \code{T} is obtained.  Although the runtime
type of \code{T} is \code{Boolean}, the static type is \code{Any}.  Therefore,
it will likely need to be cast to be useful, as demonstrated with the call to
\code{asInstanceOf[Boolean]} below.

<<getInScala>>=
s %@% '
  val result = R.get("T")
  println("The result is " + result)
  if ( result._1.asInstanceOf[Boolean] ) {
    println("Good, nobody messed with the value of T.")
  }
'
@

Instead of casting the result from the \code{get} method, it may be more
convenient to call a method that returns a specific type. The \code{RClient} class includes a suite of methods whose names start with \code{get} and end
in $XY$, where $X \in \{$\code{R}, \code{I}, \code{D}, \code{L}, \code{S}$\}$
and $Y \in \{$\code{0}, \code{1}, \code{2}$\}$.  The value of $X$ indicates
whether the result from \R should be interpreted as raw, integer, double,
logical, or character, respectively.  The value of $Y$ indicates whether the
result should be interpreted as a scalar, an array, or a
rectangular array of arrays, respectively.  This example uses the \code{getL0} method
to return the value of the variable \code{T} as a logical scalar value.

<<getInScala2>>=
s %@% 'if ( R.getL0("T") ) { println("Good, nobody messed with the value of T.") } '
@

\R expressions can be evaluated with a suite of methods whose names start
with \code{eval} and end in $XY$, where $X$ and $Y$ have the same meaning as
in the \code{get} methods.  In the example below, \R and \Scala are
used together to sample from a chi-square distribution with $100$ degrees of
freedom.

<<evalInScala>>=
set.seed(324)
s %~% 'R.evalD1("rnorm(100, sd=3)").map(math.pow(_, 2)).sum'
@

The \code{RClient} class also provides the ability to call \R functions through
methods that start with \code{invoke} and end in $XY$ (as in the \code{get} and
\code{eval} methods).  For example, the previous example could also be
implemented as follows.

<<invokeInScala>>=
set.seed(324)
s %~% '
  val mean = 100
  R.invokeD1("rnorm", mean, "sd" -> 3).map(math.pow(_, 2)).sum
'
@

The example above demonstrates the use of \Scala's builtin notation for
creating pairs (e.g., \code{"sd" -> 3}) to provide named arguments to the \R
function invoked from \Scala.  The arguments to an \code{invoke} method can be literals and variables of
copyable types, \Scala references, and NULL, where \code{NULL} is used to
indicate arbitrary \R objects.

A more interesting use case is calling a user-supplied \R function from \Scala.
First, consider an \R function that computes $f(n,\alpha)$, the expectation of
the Ewens($n$,$\alpha$) distribution or, equivalently, the expected number of
clusters when sampling $n$ observations from a discrete random measure obtained
from the Dirichlet process with mass parameter $\alpha$:

<<enc>>=
f <- function(n,alpha) sapply(alpha, function(a) sum(a/(1:n+a-1)))
f(100, 1.0)
@

In a Bayesian analysis, the Ewens distribution is a prior distribution in
random partition models and $\alpha$ is a hyperparameter.  In the prior
elicitation process, practitioners may want to find the value of $\alpha$ that
corresponds to the expert's anticipated number of clusters.  Thus, the task is
to numerically solve $f(n,\alpha) = \mu$ for $\alpha$, given fixed values for
$n$ and $\mu$.  To be specific, suppose $n=1000$ and $\mu=10$. The value
$\alpha$ can be obtained using root finding methods.
Here, we demonstrate the bisection method implemented as a
\Scala function. The function's first argument, \code{func}, takes a user-defined \R function.
The argument's type is set as \code{NULL} so its value can be referenced in \Scala without any conversion.

<<rootFinding>>=
bisection <- function(func=NULL, lower=1.0, upper=1.0, epsilon=0.000000001) s %!% '
  def g(x: Double) = R.invokeD0(func, x)
  val (fLower, fUpper) = (g(lower), g(upper))
  if ( fLower*fUpper > 0 ) sys.error("lower and upper do not straddle the root.")
  @scala.annotation.tailrec
  def engine(l: Double, u: Double, fLower: Double, fUpper: Double): Double = {
    if ( math.abs(l-u) <= epsilon ) ( l + u ) / 2
    else {
      val c = ( l + u ) / 2
      val fCenter = g(c)
      if ( fLower*fCenter < 0 ) engine(l,c,fLower,fCenter)
      else engine(c,u,fCenter,fUpper)
    }
  }
  engine(lower, upper, fLower, fUpper)
'

bisection(function(a) f(100,a) - 10, 0.1, 20)
@

The most important aspect of this example is found in the first line of the
\Scala function.  The \code{invokeD0} method calls the \code{R}
function referenced by \code{func} and returns the result as a \code{Double}.

The \rscala package supports infinite recursion (subject
to available resources) between \R and \Scala.  For example, the
\code{recursive.sum} function below repeatedly calls itself from \Scala to
compute $0+1+2+\ldots+n$.

<<recursion>>=
recursive.sum <- function(n=0L) s %!% '
  if ( n <= 0 ) 0 else n + R.invokeI0("recursive.sum", n-1)
'
recursive.sum(10)
@

\subsubsection{Memory management}

The \rscala package ties into the garbage collectors of both \R and \Scala.
As such, the user often does not need to think about memory management.
There are a few important things to note, however.  First, the default
maximum heap size set by the Java Virtual Machine may not be sufficient.
Adjust the heap size using the \code{scala} function's \code{heap.size}
argument, or use the global option \code{rscala.heap.maximum} (e.g.,
\code{options(rscala.heap.maximum="4G")}). The former takes precedence over
the latter.

Second, there is an
\href{https://issues.scala-lang.org/browse/SI-4331}{unresolved issue (SI-4331)}
with the \Scala REPL (read-eval-print-loop) where allocated memory cannot be
freed even if the same identifier is set to another value.  This issue
prevents memory from being recovered in \rscala when using the
\code{\%\mytilde\%} and \code{\%.\mytilde\%} operators, or when using the
the \code{\$} assignment operator.  This issue does not affect
\Scala functions and calls to methods on \Scala references.  Hence, we
encourage developers to use functions and methods for memory intensive applications.
As will be shown later, functions and methods also enjoy faster execution than the
equivalent code using the \code{\%\mytilde\%} and \code{\%.\mytilde\%}
operators.

\subsection[Developing packages depending on rscala]{Developing packages depending on \rscala}

The \rscala package enables developers to use \Scala in their own \R packages.  For example,
the \pkg{shallot} \citep{shallotSoftware} and \pkg{bamboo}
\citep{bambooSoftware} packages on CRAN use \Scala via \rscala to
implement statistical methodology of associated journal articles
\citep{shallotPaper,bambooPaper}.  Readers are invited to study those examples
in addition to the process described here.

An \R package based on \rscala should include \code{rscala} in the \code{Imports} field of the package's
\code{DESCRIPTION} file. Also, add \code{import(rscala)} to the \code{NAMESPACE} file.
Define an \code{.onLoad}
function which calls \code{.rscalaPackage(pkgname)}, where \code{pkgname} is
the package's name.  The \code{onLoad} function may be as simple as

<<onLoad, eval=FALSE>>=
.onLoad <- function(libname, pkgname) {
  .rscalaPackage(pkgname)
}
@

The \code{.rscalaPackage} function binds a \Scala instance to the identifier
\code{s} in the package's namespace using \R's \code{delayedAssign} function. This ensures that
the start-up cost of instantiating a \Scala instance is only incurred when
\code{s} is first used.  At that time, if \Scala itself is not already
installed, the user is asked for permission to download and install \Scala
(using the \code{scalaInstall} function).  Analogous to \rJava's
\code{.jpackage} function, the \code{.rscalaPackage} function adds the JAR
files in the source package's \code{inst/java} directory to \Scala's classpath.
Since \Scala is binary compatible only within major version, package developers
are encouraged to support major versions 2.10, 2.11, and 2.12 by placing
cross-compiled versions of \Scala JAR files in \code{inst/java/scala-2.10},
\code{inst/java/scala-2.11}, and \code{inst/java/scala-2.12}, respectively.  If
a package supports only specific major versions of \Scala, change the
\code{major.version} argument of the
\code{.rscalaPackage} function.

The \code{.rscalaPackage} function takes several optional arguments.  The
\code{classpath.packages} argument allows the package to use the JAR files of another
package.  For example, the \pkg{shallot} package uses this argument to import the
Apache Commons Mathematics Library \citep{commonsMathSoftware} JAR files distributed with the \pkg{commonsMath} package.
The rational is
that JAR files can be large and, by having them in a separate package,
they do not need to be updated as frequently.
The arguments \code{classpath.prepend} and \code{classpath.append}
provide fine-grained control over the classpath.  The argument \code{snippet}
provides \Scala expressions that will be evaluated when \Scala is
instantiated.  This feature is useful for definitions and import
statements.  Finally, other arguments to \code{.rscalaPackage} are passed
directly to the \code{scala} function.  This \code{.onLoad} function taken from the
\pkg{shallot} package demonstrates several of these optional arguments and also
shows a callback to \R so that random data generation in \Scala is based on
\R's random number seed.

<<onLoad2, eval=FALSE>>=
.onLoad <- function(libname, pkgname) {
  snippet <- '
    import org.ddahl.shallot._
    import org.apache.commons.math3.random.{ RandomDataGenerator => RDG }

    def rdg() = {
      val ints = R.evalI1("runif(2,-.Machine$integer.max,.Machine$integer.max)")
      val seed = ((ints(0).asInstanceOf[Long]) << 32) | (ints(1) & 0xffffffffL)
      val r = new RDG()
      r.reSeed(seed)
      r
    }
  '
  ## Users may want to use 'options(rscala.heap.maximum="2G")'.
  .rscalaPackage(pkgname,classpath.packages="commonsMath",snippet=snippet)
  ## This circumvents a bug in the class loader of Scala 2.11.x.
  sInfo <- scalaInfo()
  if ( ( ! is.null(sInfo) ) && ( sInfo$major.version == "2.11" ) ) {
    s$.org.apache.commons.math3.random.EmpiricalDistribution$new()
  }
}
@

A package's embedded \Scala instance should be terminated when the package is
unloaded by calling the \code{.rscalaPackageUnload} function in the
\code{.onUnload} hook as shown here.

<<onUnload, eval=FALSE>>=
.onUnload <- function(libpath) {
  .rscalaPackageUnload()
}
@

Because \rscala's syntax for calling precompiled code is very similar to
\rJava's ``high-level \code{\$} convenience operator,'' developing a package
based on \rscala can be very familiar to those accustomed to \rJava.
Take, for example, CRAN's \pkg{mailR} package: ``Interface to
Apache Commons Email to send emails from \R'' \citep{mailr}.  This package
uses \rJava and its high-level \code{\$}
convenience operator.  As a proof of concept, we ported the \pkg{mailR} package
to \rscala, replacing the dependency on \rJava.  Version 0.6 of the \pkg{mailR}
package is available on GitHub at \url{https://github.com/rpremraj/mailR/} and
our port is at \url{https://github.com/dbdahl/mailR/}.  The port involved changes to
the \code{DESCRIPTION} file, the \code{NAMESPACE} file, and two script files.  We
deleted 16 lines, added 4 lines, and modified 15 lines.  Most modifications
were simple changes. For example,

<<mailR.rJava, eval=FALSE>>=
base_dir <- .jnew("java.io.File", normalizePath(getwd()))
@

became

<<mailR.rscala, eval=FALSE>>=
base_dir <- s$.java.io.File$new(normalizePath(getwd()))
@

The difference between the two versions can be viewed here:
\url{https://github.com/dbdahl/mailR/commit/feb911f}.  Of course, porting a
package that makes frequent use of \rJava's ``low-level interface'' (e.g., the
\code{.jcall} function) will require more changes.

The
\pkg{bamboo} package was originally implemented in \rJava.  The original \rJava code is
commented out with equivalent \rscala code following immediately after.  See,
for example, \url{https://github.com/dbdahl/bamboo/blob/master/R/bamboo.R}.
This example also illustrates the difficulty in calling \Scala using \rJava
since \rJava was designed for \Java, yet \Scala provides several features that do not map directly to \Java
equivalents.  The \Scala compiler uses name mangling, behind-the-scenes code
generation, and other techniques when compiling to \Java bytecode.  Using
these \Scala features from \rJava requires, at a minimum, some
understanding of \Scala's compiler.  Often, the developer is
required to write \Java-friendly wrapper methods in \Scala that hide advanced
\Scala features.

\section[Accessing R in Scala]{Accessing \R in \Scala}

So far we have demonstrated assessing \Scala from \R.  Conversely, \rscala can
also embed an \R interpreter in a \Scala application via the
\code{org.ddahl.rscala.RClient} class.  This class is thread-safe.  Its source
code and Scaladoc are located on GitHub:
\url{https://github.com/dbdahl/rscala/}.
As a convenience, \rscala's JAR file is
available in standard repositories for use by dependency management
systems.  To include \code{org.ddahl.rscala.RClient} in a
\Scala application, simply add the following line to SBT's \code{build.sbt}
file.

<<sbt, engine="scala", eval=FALSE>>=
libraryDependencies += "org.ddahl" %% "rscala" % "2.3.0"
@

Note that,
since the necessary \R code is bundled in the JAR file,
the \rscala package does \emph{not} need to be installed in \R.
An embedded \R interpreter is instantiated as follows:

<<scalaScript0,engine="scala",engine.opts=paste0('-cp "',rscala::.rscalaJar('2.12'),'"'),comment="//",eval=FALSE>>=
val R = org.ddahl.rscala.RClient()
@

This assumes that the registry keys option was not disabled during the \R
installation on Windows.  On other operating systems, \code{R} is assumed to be
in the search path.  If these assumptions are not met or a particular
installation of \R is desired, the path to the \R executable may be specified
explicitly (e.g., \code{org.ddahl.rscala.RClient("/path/to/R/bin/R")}).  By
default, console output from \R is serialized back to \Scala.  The protocol
overhead may be reduced by using \code{serializeOutput=false} when
instantiating an \code{RClient}.

The \rscala package can be an easy and convenient way to access
statistical functions, facilitate calculations, manage data, and produce plots
in a \Scala application.  Consider, for example, wrapping \R's \code{qnorm}
function to define a method in \Scala by the same name.

<<scalaScript1qnorm,engine="scala",engine.opts=paste0('-cp "',rscala::.rscalaJar('2.12'),'"'),comment="//">>=
val R = org.ddahl.rscala.RClient()

def qnorm(x: Double, mean: Double = 0, sd: Double = 1, lowerTail: Boolean = true) = {
  R.invokeD0("qnorm", x, mean, sd, "lower.tail" -> lowerTail)
}

val alpha = 0.05
println(s"If Z is N(0,1), P(Z >= ${qnorm(alpha, lowerTail=false)}) = $alpha.")
@

In the next example, the European city that is closest on average to all other
European cites is computed using \Scala and \R's builtin dataset
\code{eurodist}.  While this statistical computation could easily be
implemented in \R, one can imagine a \Scala application that needs to perform a
more taxing calculation based on data from \R's rich data-processing functions.

<<scalaScript1europe,engine="scala",engine.opts=paste0('-cp "',rscala::.rscalaJar('2.12'),'"'),comment="//">>=
val R = org.ddahl.rscala.RClient()
val distances = R.evalD2("as.matrix(eurodist)")
val cities = R.evalS1("attr(eurodist,'Labels')")
val centralCity = distances.map(_.sum).zip(cities).minBy(_._1)._2
println(s"Europe's central city is $centralCity.")
@

The \code{RClient} also enables a \Scala application to access \R's extensive
plotting facilities.  Consider a web site developed using a \Scala-based web
framework such as \pkg{Lift}, \pkg{Play Framework}, or
\pkg{Scalatra}.  Suppose part of the web application requires
plotting historical temperature data.  Rather than looking for a \Scala library
to obtain the weather data and another library for plotting, the developer might
leverage knowledge of the \pkg{weatherData} \citep{weather} and \pkg{ggplot2}
\citep{ggplot22} packages in \R.  To access these packages, one could 
set up a server using \Rserve, RApache \citep{rapache}, CGIwithR
\citep{cgi}, or Shiny \citep{shiny}, all of which require some initial effort and ongoing maintenance
beyond the \Scala-based web framework itself.
In contrast, the marginal cost of incorporating \rscala is low, requiring only the declaration
of the dependency on \rscala in the project's \code{build.sbt} file (as shown
earlier) and a standard installation of \R with the \pkg{weatherData} and
\pkg{ggplot2} packages.
Figure \ref{screenshot} shows a screen shot of a \Scala web application using
\rscala to access these \R packages.  The web application is available here:

\begin{center}
\url{https://dahl.byu.edu/software/rscala/temperature/}
\end{center}

\begin{figure}[tb]
\begin{center}
\includegraphics{screenshot.png}
\caption{Screenshot of a web application implemented in a \Scala-based framework and accessing \R packages using \rscala.}
\label{screenshot}
\end{center}
\end{figure}

\section{Implementation and Comparison to Other Software}
\label{implementation}

The \rscala package is designed
around a client/server model using local TCP/IP sockets.

\subsection[Implementation of Scala code in R]{Implementation of \Scala code in \R}

The \code{scala} function starts a \Scala interpreter on the Java Virtual Machine using \R's
\code{system2} function. The interpreter runs code that implements an asynchronous TCP/IP server
and creates an instance of \code{scala.tools.nsc.interpreter.IMain} for \Scala's
read-eval-print-loop (REPL). The TCP/IP
server's port is randomly selected by default, but it can be fixed at a
given value.  While the \Scala
server is starting up, the \R component attempts to establish a connection using
functions from the \pkg{base} \R package.  After connecting, the \R client interfaces with the
server's REPL class by means of a custom protocol.

The \rscala package takes advantage of the \Scala REPL's ability to compile and
execute \Scala code on-the-fly as well as set and get values of
identifiers.  When a \Scala function is called for the first time (or when a
particular method of a \Scala reference is called for the first time), it is
compiled behind the scenes.  The compiled method is then
cached and re-used for subsequent calls.  As an illustration, consider the code
below and notice that the elapsed time is significantly less in the second call
to the same method.

<<fasterAfterFirstTime>>=
system.time( print(s$.sys$props("user.name")) )
system.time( print(s$.sys$props("user.name")) )
@

<<benchmarkAgainstRJava>>=
library('rJava',quietly=TRUE)
result <- .jinit(list.files(file.path(scalaInfo(s)$home,"lib"),full.names=TRUE))

rJavaReference <- .jnew("scala.util.Random")
rJavaLowLevelFunction <- function() .jcall(rJavaReference,"D","nextGaussian")

rscalaReference <- s$.scala.util.Random$new()
rscalaOptimizedFunction <- rscalaReference$nextGaussian(.EVALUATE=FALSE)

library('microbenchmark')
timings <- microbenchmark(
  rJavaLowLevelFunction(), rscalaOptimizedFunction(), rJavaReference$nextGaussian(),
  rscalaReference$nextGaussian(), times=1000)
@

<<benchmarkAgainstRJavaTable, echo=FALSE, results='asis'>>=
library(xtable)
sumTimings <- summary(timings)
units <- attr(sumTimings,"unit")
reps <- sumTimings[1,"neval"]
sumTimings <- sumTimings[,c("expr","lq","mean","median","uq")]
sumTimings[,1] <- paste0("\\code{",sumTimings[,1],"}")
colnames(sumTimings) <- c("Expression","Q1","Mean","Median","Q3")
xtab <- xtable(sumTimings)
caption(xtab) <- paste0("Comparison of execution time of various ways to call the \\code{nextGaussian} method of an instance of the \\code{scala.util.Random} class.  Since the method itself is relatively fast, the timings here give an indication of the overhead involved in the various techniques.  Each expression was evaluated ",reps," times and the results are in ",units,".")
print(xtab,include.rownames=FALSE,booktabs=TRUE)
@

Callback functionality is implemented over the same TCP/IP sockets.
Immediately after the \R client requests the execution of \Scala code, \R
becomes a temporary, embedded server to allow the \Scala code to access the \R
interpreter through the \code{R} object (an instance of the \code{RClient}
class).  The embedded \R server interprets code and sets/gets values using the
\code{parse}, \code{eval}, \code{assign}, and \code{get} functions.  After the
\Scala server executes the \Scala code, it tells the embedded \R server to exit
and the \Scala server resumes its usual behavior.

\subsection[Implementation of R code in Scala and other JVM applications]{Implementation of \R code in \Scala and other JVM applications}

The functionality that allows \Scala, \Java, and other JVM-based applications
to access an embedded \R interpreter is achieved by reusing the
previously-discussed callback functionality.  In this case,
however, there is not an existing instance of the \R interpreter.  The class
\code{RClient} spawns an \R instance, connects the \R
client to the \Scala server, and then immediately starts the embedded \R
server.  There are two versions of the \R client. The \Java
version (\code{org.ddahl.rscala.RClient4Java}) is a thin wrapper over the
\Scala version (\code{org.ddahl.rscala.RClient}).  The wrapper hides \Scala-specific
features and provides familiar Javadoc to \Java developers.

\section{Comparisons to other software}
\label{comparisons}

In this section we compare and contrast the \rscala package to other related
software.

\subsection[Comparison to rJava]{Comparison to \rJava}
\label{vsRJava}

The \rJava package, together with the included JRI (Java/R interface) software for callbacks,
serves as inspiration for our \rscala package.  Indeed, we adopt \rJava's
high-level \code{\$} convenience operator in \rscala.  The
implementations of the two packages are, however, quite different.  The \rscala
package uses TCP/IP sockets for communication between processes.  As a
consequence, \R, \Scala, and/or \Java can be updated without
reinstalling the package.  In contrast, \rJava uses \Java's JNI (Java native interface) to
dynamically load the JVM shared library in \R's process space.  The versions of
\R and \Java must be compatible (i.e., both 32-bit or both 64-bit binaries) and
updates to either \R or \Java usually require reinstalling the package or
running \code{R CMD javareconf}.  Callbacks are provided in \rJava using the
JRI software included with the \rJava package. This requires that \R be
compiled with the option \code{\textemdash{}enable-R-shlib}. This option is enabled by
default on Windows and Mac OS X, but it is not enabled for most Linux
distributions.  While installing \rJava requires a bit more care and
maintenance, we will see in Section \ref{benchmarks} that it invokes methods
faster than \rscala does.  JRI also provides a richer interface to \R objects
than does \rscala.

Since \Scala compiles to \Java bytecode and runs on the Java Virtual Machine,
some of the functionality in the \rscala package can be replicated using the
\rJava package.  Both \rscala and \rJava can call precompiled \Java bytecode.
Features that \rJava does not support include defining inline functions
(Section \ref{inline}), evaluating arbitrary code (Section \ref{evalCode}), and
explicit support for \Scala.

We now consider the difficulty of calling \Scala from \rJava.  After working on
several projects using \rJava to access \Scala code in \R, we found that \Scala
was cumbersome to use.  \Scala provides several features that do not map
directly to \Java equivalents.  The \Scala compiler uses name mangling,
behind-the-scenes code generation, and other techniques when compiling to \Java
bytecode.  Calling \Scala code that makes use of these features from \rJava
requires some understanding of \Scala's compiler at a minimum, but often the
developer is required to write a \Java-friendly wrapper method in \Scala that
hides advanced \Scala features.  We illustrate this scenario with a few
examples.  Consider the following \Scala code:

<<scalaScript20,engine="scala",engine.opts=paste0('-nowarn -cp "',rscala::.rscalaJar('2.12'),'"'),comment="//">>=
// Scala code
val a = List[String]("apples", "bananas")

var b = List.empty[String]
b = "bananas" :: b
b = "apples"  :: b

println(a == b)
@

The equivalent \R code to create the objects \code{a} and \code{b} in \Scala using the \rscala package
is a straight-forward syntactic translation:

<<rscalaEquivalent>>=
a <- s$do('List')$apply('apples', 'bananas')

b <- s$do('List')$'empty[String]'()
b <- b$'::'('bananas')
b <- b$'::'('apples')

cat( a$'=='(b) )
@

There appears to be no translation of the \Scala code to create the object
\code{a} using the \rJava package.  This is because the \Scala compiler uses
internal classes to implement the \emph{varargs} in the \code{apply} method.
One solution would be to write a \Java-friendly wrapper method that the
developer could call using \rJava.  The object \code{b} can be created in \R
using the \rJava package, but the developer has to know: i.\ that the \code{::}
method gets renamed to \code{\$colon\$colon} because \code{::} does not conform
to JVM specifications, ii.\ that the \Scala companion object \code{List} is
represented in \Java bytecode by the class \code{List\$}, and iii.\ that
\Scala's \code{==} method compiles to \Java's \code{equals} method.  Below is
the equivalent \R code using the \rJava package, except one cannot translate
the \Scala code for the object \code{a} to an \rJava equivalent:

<<rJavaEquivalent>>=
@

\clearpage
\subsection[Comparison to Rcpp]{Comparison to \Rcpp}
\label{vsRcpp}

From a user's perspective, the \rscala package is very similar to the \Rcpp
package \citep{rcpp}, with the obvious difference that \rscala supports \Scala
and \Rcpp supports \Cpp and \C.  Both packages allow the user to define an
inline function within \R and return an \R function which wraps the
newly-compiled function.  Both also support callbacks to the original \R
interpreter and both provide a foundation for building other packages.  Whereas
\Rcpp loads dynamically-compiled code into R's process space, \rscala uses
TCP/IP sockets for communication between the \R and JVM processes.  The
benchmarks in Section \ref{benchmarks} will show that \Rcpp is generally unmatched in
execution speed, especially for short-lived function calls.

\subsection[Comparison to Rserve]{Comparison to \Rserve}
\label{vsRserve}


Those who are interesting in accessing \R from \Scala should also consider
\Rserve \citep{rserve} which, like \rscala, is ``a TCP/IP server which allows
other programs to use facilities of \R'' (\url{http://www.rforge.net/Rserve}).
\Rserve clients are available for many languages including \Java and therefore
\Scala (since \Scala can call \Java code).  \Rserve is fast and provides a much
richer API than \rscala, but requires that \R be compiled with the option
\code{\textemdash{}enable-R-shlib} (which is the default on Windows and Mac OS
X, but is not for some Linux distributions).  \Rserve also has some limitations
on Windows and the user is advised to not ``use Windows unless you really have
to'' (\url{http://www.rforge.net/Rserve/doc.html}).

Conversely, \rscala provides the same functionality on all operating systems
and uses a standard installation of \R. 

\Rserve \citep{rserve} ``is a TCP/IP server which allows other programs to use facilities of
\R... without the need to initialize \R or link against [the] \R library''
(\url{http://www.rforge.net/Rserve}).  Whereas the \rscala package only
supports \Scala, \Java, and other JVM-based applications, a client for \Rserve
can be written in any language that supports TCP/IP sockets.  Clients are
currently available for \Java, \Cpp, \R, \Python, \Csharp, \proglang{.Net/CLI},
and \Ruby.  Note that \rJava's JRI links against the \R library and one of the
benefits of the \Rserve's client/server approach is that it ``prevent[s]
multi-threading problems that arise when linking against \R library directly''
(\url{http://www.rforge.net/Rserve/doc.html}).  The \rscala package shares this benefit
because it too is implemented using a client/server approach.  Like \rJava's
JRI, however, \Rserve requires that \R be compiled with the option
\code{\textemdash{}enable-R-shlib} which is the default on Windows and Mac OS X, but is
not the default on most Linux distributions.  The \rscala package uses a
standard installation of \R on all platforms.  \Rserve provides the same rich
interface to \R objects as \rJava.  Benchmarks in Section \ref{benchmarks} will
show that \Rserve is faster than \rscala.  Finally, we note that \rscala is
neutral with respect to choice of operating system, but \Rserve has some
limitations on Windows and the user is advised to not ``use Windows unless you
really have to'' (\url{http://www.rforge.net/Rserve/doc.html}).

\subsection{Benchmarks}
\label{benchmarks}

In this section we explore the performance of the \rscala package relative to
other software used to accomplish the same tasks.  All benchmarks were run in
\R 3.2.0 compiled from source with the option \code{\textemdash{}enable-R-shlib}.
The following packages were installed from CRAN: \rscala 1.0.6, \rJava 0.9.6,
\Rcpp 0.11.5, \Rserve 1.7.3, and \pkg{microbenchmark} 1.4.2 \citep{micro}.  The benchmarking
workstation runs Ubuntu 14.04.02, has 32GB of RAM, and has an Intel i7-3930K
CPU with 6 cores and hyperthreading enabled yielding a total of 12 virtual cores.
The workstation has \Scala 2.11.6 and \Java 1.7.0\_17.  Unless stated
otherwise, our benchmarking functions are single-threaded.

\subsubsection{Computing the mean of a sample}
\label{benchmarksForward}

Consider the simple task of computing the mean of a random sample of size $n$
from the uniform distribution on the unit interval.  We explore several
implementations of this task through two functions based on standard \R, one function based on
\Rcpp, three functions based on \rJava, and five functions based on \rscala.
For example,
\code{standardR2}, \code{rJava1}, \code{rJava2}, \code{rscala1}, and
\code{rscala2} all involve looping in \R instead of the compiled code.
Other reasons for the different versions include calling inline
functions versus precompiled code and using package-specific features such as
\rJava's low-level and high-level interfaces.  The online supplement
has the complete source code for functions and benchmarking.  Note that the \R
and \Rcpp functions use the same underlying \C code to sample random uniforms.
Likewise, \rJava and \rscala use the same code to sample random uniforms, but
this code is different from that used by \R and \Rcpp.  We find that the \Rcpp
function is the fastest (not listed in the table) and choose it as the
reference from which performance ratios of the other methods are calculated.

\begin{table}[tb]
\scriptsize
\centering
\begin{tabular}{l|rr|rr|rr|rr|rr}
  \toprule
             & \multicolumn{2}{c|}{1 Sample} & \multicolumn{2}{c|}{10 Samples} & \multicolumn{2}{c|}{100 Samples} & \multicolumn{2}{c|}{1,000 Samples} & \multicolumn{2}{c}{10,000 Samples}\\
  Function   &  Seconds &   Ratio &  Seconds &   Ratio &  Seconds &   Ratio &  Seconds &   Ratio &  Seconds &   Ratio \\
  \midrule
  \texttt{standardR2} &   0.0000 &       2 &   0.0000 &       4 &   0.0002 &      19 &   0.002 &      84 &   0.02 &      135 \\
  \texttt{rJava1}     &   0.0003 &      65 &   0.0008 &     109 &   0.0054 &     481 &   0.042 &   1,864 &   0.40 &    2,685 \\
  \texttt{rJava2}     &   0.0023 &     442 &   0.0176 &   2,275 &   0.1567 &  14,005 &   1.524 &  67,266 &  15.22 &  101,530 \\
  \texttt{rscala1}    &   0.0017 &     336 &   0.0091 &   1,174 &   0.0643 &   5,744 &   0.455 &  20,097 &   4.47 &   29,808 \\
  \texttt{rscala2}    &   0.0018 &     351 &   0.0083 &   1,077 &   0.0582 &   5,200 &   0.405 &  17,873 &   3.94 &   26,263 \\
  \bottomrule
\end{tabular}
\caption{Benchmarks of functions whose performance relative to the \Rcpp function gets worse as the sample size $n$ increases.  The definitions of the functions are provided in the online supplement.}
\label{benchmarkForwardWorse}
\end{table}

Using the package \pkg{microbenchmark}, we run the benchmarking
functions 50 times for each of the following sample sizes for $n$:  1, 10, 100,
\ldots, 10,000.  We find that as $n$ increases, the performance relative to
\Rcpp gets worse for some functions.  Their results are displayed in
Table~\ref{benchmarkForwardWorse}.  Each of these functions involves looping in
\R instead of the compiled code.  Among these slow implementations, we note
that \code{standardR2} is the fastest and that the performance of the \rscala
implementations lies between two \rJava implementations. The only difference in
these two \rJava implementations is that the slower version uses the high-level
\code{\$} convenience operator.

\begin{table}[tb]
\scriptsize
\centering
\begin{tabular}{l|rr|rr|rr|rr|rr}
  \toprule
             & \multicolumn{2}{c|}{1 Sample} & \multicolumn{2}{c|}{100 Samples} & \multicolumn{2}{c|}{10,000 Samples} & \multicolumn{2}{c|}{1,000,000 Samples} & \multicolumn{2}{c}{100,000,000 Samples}\\
  Function   &  Seconds &   Ratio &  Seconds &   Ratio &  Seconds &   Ratio &  Seconds &   Ratio &  Seconds &   Ratio \\
  \midrule
  \texttt{standardR1} &   0.0000 &    2.9 &   0.0000 &    2.9 &   0.0006 &    2.3 &   0.0379 &    2.31 &   3.2078 &    2.27 \\
  \texttt{rJava3}     &   0.0001 &   18.3 &   0.0001 &   14.5 &   0.0005 &    2.1 &   0.0232 &    1.41 &   2.1679 &    1.53 \\
  \texttt{rscala3}    &   0.0005 &  123.5 &   0.0009 &  144.0 &   0.0019 &    8.1 &   0.0436 &    2.65 &   3.4078 &    2.41 \\
  \texttt{rscala4}    &   0.0005 &  117.5 &   0.0005 &   84.6 &   0.0013 &    5.5 &   0.0259 &    1.58 &   2.1679 &    1.53 \\
  \texttt{rscala5}    &   0.0005 &  117.1 &   0.0005 &   84.9 &   0.0012 &    5.0 &   0.0258 &    1.57 &   2.1686 &    1.53 \\
  \bottomrule
\end{tabular}
\caption{Benchmarks of functions whose performance relative to the \Rcpp function gets better as the sample size $n$ increases.  The definitions of the functions are provided in the online supplement.}
\label{benchmarkForwardBetter}
\end{table}

We test the other functions for even larger $n$: 1, 100, \ldots, 100,000,000.
The performance of the other functions improves with $n$ but seems to
asymptote.  These results are displayed in Table~\ref{benchmarkForwardBetter}.
The functions \code{rJava3} and \code{rscala5} call exactly the same \Java
bytecode and the initial performance difference is due to the overhead for the
TCP/IP protocol used by \rscala.  As $n$ increases, the performance difference
virtually disappears. The function \code{rscala4} is written in \Scala using a
while-loop and compiles to essentially the same \Java bytecode used in
\code{rJava3} and \code{rscala5}.  The function \code{rscala3} demonstrates the
well-known fact that for-loops in \Scala are not optimized for performance.

\clearpage
\subsubsection[Calling into the JVM and back into R]{Calling into the JVM and back into \R}
\label{benchmarksBack}

To further investigate the performance of \rscala relative to other software,
we benchmark the performance of \Rcpp, \rJava, and \rscala in calling a very
simple \R function:

<<sleepFunction, eval=FALSE>>=
sleep <- function(secs) {
  Sys.sleep(secs)
  rnorm(1)
}
@

This function takes an argument \code{secs} and pauses the function for the
specified time.  Although this function is of little practical utility, we use
it to simulate functions in \R whose execution may be very fast (by sleeping 0
seconds), somewhat computationally expensive (by sleeping 1 second), and
something in between (by sleeping 0.01 seconds).  It is interesting to
investigate the invocation overhead of the three methods in calling the
functions with the different sleep times.  The online supplement has
complete code for the functions and benchmarking.  The \rJava function uses the
low-level interface (as opposed to the high-level \code{\$} convenience
operator) for performance reasons.  The \Rcpp function is again the fastest and
we use it as the reference when calculating performance ratios for the other
methods.

\begin{table}[tb]
\scriptsize
\centering
\begin{tabular}{l|rr|rr|rr}
  \toprule
             & \multicolumn{2}{c|}{1 Second Sleep} & \multicolumn{2}{c|}{0.01 Seconds Sleep} & \multicolumn{2}{c}{0 Seconds Sleep} \\
  Function                 & Seconds& Ratio & Seconds& Ratio &Seconds & Ratio   \\
  \midrule
  \texttt{callback.Rcpp}   & 1.0011 & 1.000 & 0.0101 & 1.003 & 0.0000 &   6.246 \\
  \texttt{callback.rJava}  & 1.0013 & 1.000 & 0.0102 & 1.013 & 0.0001 &  22.559 \\
  \texttt{callback.rscala} & 1.0031 & 1.002 & 0.0116 & 1.156 & 0.0012 & 237.130 \\
  \bottomrule
\end{tabular}
\caption{Benchmarks of functions calling a simple \R function that sleeps for 1, 0.01, and 0 seconds.
Performance ratios are relative to the \Rcpp function.  The definitions of the functions are provided in the online supplement.}
\label{benchmarkBack}
\end{table}

We see from Table~\ref{benchmarkBack} that the \rscala function has the highest
invocation latency.  The ratios indicate that the protocol overhead is
important for short-lived \R functions (i.e., when sleeping 0 seconds) but
negligible for long-lived \R functions (i.e., when sleeping 1 second).

\subsubsection[Calling into R from a JVM application]{Calling into \R from a JVM application}
\label{benchmarksJVM}

We now consider the performance and simplicity of calling \R code from within a
\Java application.  Suppose there is an array of doubles in the \Java
application and we wish to produce a normal q-q plot of the data using \R.  We
compare an \rscala solution against two alternatives:  i.\ spawning a separate
\R process using the \Rscript executable, and ii.\ using the \Java client for
\Rserve.  We measure the time needed to produce 200 plots of randomly-generated
data.  The online supplement contains the related \Rscript and \Java source code.

Spawning a separate \R process using \Rscript requires somewhat tedious coding
to save the data to a file for \R to read and plot.  Further, since a new \R
process is started for each plot, the performance is rather poor as well, taking
a total of 26.7 seconds for the 200 plots.  Conversely, the \Rserve and
\rscala solutions are both more convenient and quite similar.  The \Rserve
solution takes only 0.6 seconds and the \rscala solution takes 1.4 seconds
demonstrating that the protocol overhead of \Rserve is less than that of
\rscala.

\section{Case studies}
\label{caseStudies}

\subsection{Bayesian logistic regression}
\label{logisticRegression}

In this section we use a custom Markov chain Monte Carlo (MCMC) algorithm to
fit a Bayesian logistic regression model in \R.  This model can also be
estimated in \R through a variety of other algorithms using \R packages such as
RStan \citep{stan-manual:2014}, rbugs \citep{Rbugs}, R2jags \citep{r2jags},
rjags \citep{Rjags}, R2WinBUGS \citep{r2winbugs}, R2OpenBUGS
\citep{r2openbugs}, and BRugs \citep{brugs}.  Our interest here,
however, is \emph{not} to determine the best algorithm for Bayesian model
fitting, but rather to compare the convenience and computational speed of
\Scala, \C, and standard \R in implementing the same commonly-used,
computationally-expensive algorithm.

Studies show that babies who breastfeed have a significantly reduced risk of
health problems such as HIV, obesity, and neurological defects due to the
fact that milk contains natural immune components that are not present in baby
formula \citep{standby}.  Medical professionals have observed that premature
babies take longer to learn how to breastfeed and many are not breastfeeding by
the time they are ready to leave the hospital \citep{standby2}.  To quantify
this relationship, a statistician wishes to fit a logistic regression model in
which the probability of breastfeeding before leaving the hospital is modeled
as a function of gestational age.  Data is available on $n=64$ infants where
$y_i = 1$ if the baby is breastfeeding at departure and $x_i$ is the
gestational age.  The model is
\[
\text{Pr}(y_i = 1) \ = \ \frac{1}{1+\exp\{-(\beta_0 + \beta_1 x_i)\}}
\]
where $\beta_0$ and $\beta_1$ are unknown parameters to estimate.  We assume
independent Normal($-15$, $5$) and Normal($1$, $1$) priors on $\beta_0$ and
$\beta_1$, respectively.

Since the model is not conjugate, we obtain samples from the joint posterior
distribution using a Metropolis sampling algorithm with a uniform random walk.
We examine the convenience and computational speed of running a single MCMC
chain as well as simultaneously running 6 and 12 independent chains in
parallel.  Recall that the test machine has 6 cores and hyperthreading is enabled
making it appear that there are 12 cores.  We run the chains for 1,001,000
iterations using the prior means as the starting state.  We discard the first
1,000 iterations for burn-in. This same MCMC algorithm is implemented in \Scala
using \rscala, in \C using the \code{.C} interface, and in standard \R.  Note
that a \C implementation using the \code{.Call} interface requires a more
intimate knowledge of \R's \C API.  The implementations, data, and benchmarking
code are all available in the online supplement.

\begin{table}[tb]
\centering
\begin{tabular}{r|rr|rr|rr}
  \toprule
 & \multicolumn{2}{c|}{1 core} & \multicolumn{2}{c|}{6 cores} & \multicolumn{2}{c}{12 cores} \\
Language & Seconds & Ratio & Seconds & Ratio & Seconds & Ratio \\
   \midrule
\Scala using \rscala  & 1.12 & 1.00 & 0.29 & 1.00 & 0.18 & 1.00 \\
\C using \code{.C}    & 1.48 & 1.32 & 0.31 & 1.09 & 0.24 & 1.36 \\
Standard \R           & 15.79   & 14.11 & 3.78 & 13.15 & 2.70 & 15.08 \\
   \bottomrule
\end{tabular}
\caption{Breastfeeding infants example:  Wall time and relative performance of three implementations of the same
algorithm using 1, 6, and 12 cores.}
\label{mcmcInfant}
\end{table}

The results are in Table~\ref{mcmcInfant} along with wall times and performance
ratios (relative to \Scala).  Surprisingly, we find that the \Scala
implementation is slightly faster than the \C implementation.  This may be due
to the fact that the \Scala code uses a different library for evaluating the
log of the binomial probabilities or because the \code{.C} interface is not as
performant as the \code{.Call} interface.  The standard \R implementation is
about 13-15 times slower.

The breastfeeding infants example involves $n=64$ observations at one of six
unique values of the predictor.  To see how the results might change for larger
datasets, we simulated a dataset of $n=20,000$ observations at one of 200
unique values of the predictor.  The results are found in
Table~\ref{mcmcSimulated}.  The most striking finding is that the standard \R
implementation improves dramatically, now being only 1.4-1.6 times slower than
the \Scala implementation.  The explanation is that the standard \R
implementation, for this simulated data example, spends 72.5\% of the time in
the function \code{dbinom}.  This function is implemented in \C using the
\code{.Call} interface.  It is not surprising that a \C implementation
and another implementation based mostly on \C (i.e., the standard \R
implementation) perform similarly.

\begin{table}[tb]
\centering
\begin{tabular}{r|rr|rr|rr}
  \toprule
 & \multicolumn{2}{c|}{1 core} & \multicolumn{2}{c|}{6 cores} & \multicolumn{2}{c}{12 cores} \\
Language & Seconds & Ratio & Seconds & Ratio & Seconds & Ratio \\
   \midrule
\Scala using \rscala  & 47.35 & 1.00 & 10.82 & 1.00 & 7.87 & 1.00 \\
\C using \code{.C}    & 53.17 & 1.12 & 11.49 & 1.06 & 7.67 & 0.97 \\
Standard \R           & 75.51 & 1.59 & 16.15 & 1.49 & 11.30 & 1.44 \\
   \bottomrule
\end{tabular}
\caption{Simulated data example:  Wall time and relative performance of three implementations of the same
algorithm using 1, 6, and 12 cores.}
\label{mcmcSimulated}
\end{table}

\subsection[Scala web application using R]{\Scala web application using \R}
\label{webApp}

\section{Conclusion}
\label{conclusion}

This paper introduced the \rscala package that allows users to seamlessly
incorporate \R and \Scala in one program, exploiting each language's respective
strengths.  We believe that the \rscala package is stable and complete.  In the
future, we would like to support more data structures in \R (e.g., lists and
data frames).  While callbacks from \Scala to the original \R interpreter are
supported, we would also like to support callbacks
from \R to \Scala as well.  We also suspect that our client/server protocol
could be extended to support other JVM-based languages such as Jython
\citep{jython} and jRuby \citep{jruby}.

%Known issues:  Incomplete lines.  Tab completion.

\section*{Acknowledgements}

The author's work on this paper is supported by NIH NIGMS R01 GM104972.  The
author thanks the following students: Floid Gilbert, Deepthi Uppalapati, Scott
Ferguson, and Richard Payne.

\bibliography{refs}

\setcounter{section}{0}
\renewcommand{\thesection}{Appendix \Alph{section}}

\end{document}

